
#### 本文主要阐述以下:
* ---梳理众所周知的短小函数的好处
* ---解释为什么我认为有些好处表现的并不好
* ---解释为什么短小函数是适得其反的
* ---列举我认为短小函数真正有用的场景

人们给出的编程建议似乎都在赞美短小函数的优美和简洁。比如被看做编程圣经的《clean code》一书中，有一章专门用来讲述方法。这一章用一个非常差劲的函数做开篇，这个函数就非常冗长。这一章也把函数过长看做最大的错误。书中写到：
> 这个函数不仅非常长，而且有很多重复代码、使用了很多奇怪的字符串和不常见的数据类型和api。给你三分钟，你能够理解者函数吗？答案也许是否定的。这个函数中实现了太多逻辑，有很多不同层级的抽象。在if控制语句中有太多奇怪的字符串和古怪的函数调用。

这一章探讨了哪些特性能够使代码“易于阅读和理解”、“allow a casual reader to intuit the kind of program they live inside”，在探讨这些之前简化函数也许就能够达到以上目的。

函数应该短小这个观点几乎被认为是不容置疑的。这种论点频繁出现在代码审查、twitter讨论、会议演讲、书籍播客、关于重构的文章中等等各种场景。几天前我在tweeter上看到了这种观点：

在他的tweeter上、粉丝中、还有他关于函数长度的文章中，他这样说道：
> 如果你需要花费一些力气才能读懂某一个代码片段的时候，这就意味着你应该把这段代码提取到另外一函数中去。
之前我接受了这个建议，并养成了书写短小函数的习惯，通常我的函数只有几行。多余6行代码的函数让我感觉不自在，只有一行代码的函数在我这里也是平常的了。

短小方法的关键被广泛传播，今天我又在tweeter上看到一条：
> Matin Fowler的一份关于代码注释的方案中提到：再开始注释之前，是否可以让函数达到自我注释的状态。我遵从这个原则一段时间之后发现，这对写出整洁的代码很有帮助。但是最好在想要让代码更清晰的地方去调用这种自我解释的函数。

一些人貌似非常痴迷于短小函数，以至于把所有一切哪怕看起来只是nominally complex的代码逻辑抽象成方法的做法都被热烈的拥护。

我研读过一些人写的代码库。他们把短小函数这种想法发展到了一种非常极端的程度，使得最终结果很坏甚至跟所有好的想法完全相反。在这篇文章中我希望向大家解释为什么有些常常被兜售的短小方法的益处并不会像大家想象的一样表现。而在某些场景下这种想法却被证明是适得其反的。

### 一些假定的短小函数的好处
有一大堆理由去证明更短小的函数的价值。

#### 一个函数只做一件事
这种想法非常简单——函数只做一件事并且做好。从表面看非常合理，甚至这跟UNIX的编程哲学是吻合的。

但是“一件事”的定义是模糊的。这“一件事”可以是一个简单的return语句、一个表达式、一个数学运算、或者一次网络调用。照这样来说，这个“一件事”表示仅有一个层级的抽象。

举个例子，在一个web项目中，“创建一个用户”也表示“一件事”。通常来说，这个操作至少是在db中增加一条记录。另外，创建用户也可能包含给用户发送一封欢迎邮件。此外，也许有的项目需要触发一次事件，用来通过类似kafka这种消息系统来通知其他系统。

因此，"仅有一层逻辑的抽象"并不是只有一层。我发现，那些完全接受“一个函数只做一件事”这种观念的程序员，会抑制不住的想要递归的把这种思想应用到每个函数上去。

结果就是，之前我们通常把一个合理、易于理解的抽象或者封装作为一个单元。现在却要继续切割这个单元，知道每个函数都是“只做一件事”，直接完全模块化和达到了完完全全的DRY(dont repeat yourself)(不写重复代码)。

#### 对DRY原则的误解
DRY原则和把函数做的尽量小并不完全相同，我发现把函数做小通常会最终实现DRY。在我看来DRY是一个好的编程指导原则，但是很多时候是更多的时候是一种坏的指导。如果教条的遵从DRY原则，实用主义和理智往往会被牺牲。

Raymond Hettinger是一位Python的主要开发者，他做过一次非常棒的演讲Beyond PEP8: Best practices for beautiful, intelligible code。这是一个必看的视频，不仅仅对Python开发者，包括所有对编程感兴趣或者以编程为生的人。他严厉批判了对PEP8的教条遵从。所以，对他思想的理解要比对PEP8的内容要重要的多。

即使你没有观看整个视频，也应该看一看这一分钟的视频。他在这里把DRY原则必做海妖。如果人们一味的遵从DRY原则，那么就会只见树木不见森林。


我对DRY原则的质疑是：它强制进行抽象，结果往往是层级非常多、设计不合理。理论上说可以做到完美的抽象，所以我们努力的话也能够做到足够好的抽象。但是这里的“足够好”很难定义，它依赖于许多因素。

在接下来的段落中，“抽象”跟“方法”等同。例如，当我们考虑如何更好的设计A这个函数（抽象）的时候，我们应该考虑如下几点：
* A的作用，这个作用如何能够站住脚
* A的上下层级关系，这些上下层级的可扩展性、鲁棒性
* 将来可能出现的A的上下级

我们设计的A，将来不可避免的要经常重新考虑设计、局部不合理设置完全废弃。所以，为了应对将来的频繁改动，我们首要目标是让A具备可扩展性。

严格的执行DRY原则，意味着代码十分简略，也意味着这份代码不能够适应将来的一些改动。我们的首要任务是让代码能够有足够的可扩展性，而不是一个完美的长度。

最好的抽象不是完美的而是优化的足够好。它是一种特征，不能成为bug所在。理解这一点对设计出好的抽象至关重要。

Alex Martelli是duck-typing合pythonista的创造者，他有一个名为《The Tower Of Abstraction》的演讲，这些幻灯片非常值得一看：
> 如何做到好的抽象
> * 考虑到集中可能的继承者
> * 考虑到几种可能的调用

> 所有的抽象都有风险
> * 只有了解了所有细节，再动手去做抽象

著名的ruby开发者Sandi Metz有一个著名的演讲《all the little things》，在演讲中她说道：重复比错误的抽象代价更低，所以她更倾向于重复。

在我看来抽象很难被完全界定为对或者错。因为对错的界限本来就很模糊且不断变动。也许一个需求变动或者错误报告就让我们精心设计出来的抽象结构被判定为错误了。

我认为，就像文章上面提到的，我们把抽象看做一个频谱。频谱的一端趋向于精确，我们代码的每一个细节都是精确无比的。这当然有它的好处，但是这对抽象不没有太多好处。频谱的另一端趋向于不精确。

与其他事情一样，理想情况处于两个极端之间的某个地方。并没有一个万全之策的中间位置。理想情况也会随着很多因素不断变动：编程需要或者人为因素。一个优秀的工程就是要根据给出的需求找到“理想答案”在频谱中的位置，并不断的重新评估、重新校准“理想答案”。


### 游戏的名字
说到抽象，一旦决定了把哪些代码以何种方式抽象出来，接下来就需要好好起个名字了。

但是，命名往往又是很难的事情。

我们往往被建议起一个比较长、比较有意义的名字，这个编程实践中被当做了一个真理。更有甚者建议用函数名字代替注释。这种观点是在证明：函数名阐述的内容越多，封装做的越好。
> 很多朋友很粉丝建议写更具有解释性的名字。如下：
> soWeEndUpWithNamesLikeThisWhichMakesItVeryHardToRead

以上现象可能在Java中比较常见，这门语言中冗长比较常见，但是我从没见过哪个函数名这么长却又十分易读的。我们看到的只是一个只有4/5行代码的函数，却又一个极其冗长的名字。如果我读代码时突然看到这种非常长的单词，我首先需要分解这个长单词、然后再跟我已经建立的上下文联系起来，最后还需要决定是否需要跳转到这个函数的定义处去看看这个函数的实现，整个过程非常繁杂。

短小函数的问题就在于，当我们追求函数的短小时，结果是我们会想要更加短小的函数，同时我们又要秉承字解释、少注释的原则，最终我们往往会给出极其冗长的函数名。

按照以上原则，结果就是阅读代码更困难了：解读冗长的函数名、把函数名跟上下文联系、决定哪些函数进一步阅读哪些跳过、整体理解代码。
> 更短小的函数意味着更多的函数，就会有更多的函数名，我宁愿阅读代码。

我个人认为，语言自带的关键字、结构、管用语法比个人命名的变量、函数更容易阅读。比如，当我阅读if-else结构的时候，我几乎不会在if else这些关键词上花费时间，而是更多的关注分支结构内部的逻辑。

当我阅读代码的时候很容易被这种突兀的名字打断：aVeryVeryLongFuncNameAndArgList。尤其是当这个函数的内部实现只有短短一行的时候，这种情况完全不做抽象直接放到函数内部。上线问切换是很昂贵的操作，对CPU和程序员的思考是一样的。

追求短小函数的另外一个弊端是：代码库变得更难搜索了。比如createUser很容易理解，也很容易用grep搜索到。但是renderPageWithSetupsAndTeardowns(clean code这本书中的一个正面示例) 这个函数就很难记住、搜索了。有些作者甚至会做更复杂的搜索，所以有共同前缀的这种命名就不方便了。






----------------

via：https://medium.com/@copyconstruct/small-functions-considered-harmful-91035d316c29

译者：[wkpaochuan](https://github.com/wkupaochuan)

本文由 [GCTT](https://github.com/studygolang/GCTT) 原创编译，[Go 中文网](https://studygolang.com/) 荣誉推出
